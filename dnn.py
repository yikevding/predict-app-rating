# -*- coding: utf-8 -*-
"""proj.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WGhQa70K1iV1IE6QIVWl2IdPFSjXmK_t
"""

from keras.callbacks import ModelCheckpoint
from keras.models import Sequential
from keras.layers import Dense, Activation, Flatten
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error
import numpy as np
import pandas as pd
from google.colab import files
import io

uploaded=files.upload()

data=pd.read_csv(io.BytesIO(uploaded['filtered2.csv']))
y = data["Rating"].to_numpy()
data = data.drop(["Category", "Free", "Minimum Android", "Content Rating"], axis=1)
Xs = data.drop(["Rating"], axis=1).to_numpy()

# split dataset
xTrain, xTest, yTrain, yTest = train_test_split(Xs, y, test_size=0.2)

scaler = StandardScaler()
xTrain = scaler.fit_transform(xTrain)
xTest = scaler.transform(xTest)

model=Sequential()

## input layer
model.add(Dense(128,kernel_initializer='normal',activation='relu',input_dim=xTrain.shape[1]))

## hidden layer
model.add(Dense(256,kernel_initializer='normal',activation='relu'))
model.add(Dense(256, kernel_initializer='normal', activation='relu'))
model.add(Dense(256, kernel_initializer='normal', activation='relu'))

# output layer
model.add(Dense(1,kernel_initializer='normal',activation='linear'))

# compile network to get summary
model.compile(loss='mean_squared_error',optimizer='adam',metrics=['mean_squared_error'])
model.summary()

checkpoint_name = 'Weights-{epoch:03d}--{val_loss:.5f}.hdf5' 
checkpoint = ModelCheckpoint(checkpoint_name, monitor='val_loss', verbose = 1, save_best_only = True, mode ='auto')
callbacks_list = [checkpoint]

model.fit(xTrain, yTrain, epochs=100, batch_size=32, validation_split = 0.2, callbacks=callbacks_list)

wights_file = 'Weights-087--0.41762.hdf5' # choose the best checkpoint 
model.load_weights(wights_file) # load it
model.compile(loss='mean_squared_error', optimizer='adam', metrics=['mean_squared_error'])

predictions=model.predict(xTest)

mean_squared_error(yTest,predictions)